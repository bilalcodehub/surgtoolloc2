# AUTOGENERATED! DO NOT EDIT! File to edit: 04_baseline.ipynb.

# %% auto 0
__all__ = ['images_df', 'vocab', 'dblock', 'dls', 'metrics_cfg', 'y1_labeller', 'y2_labeller', 'y3_labeller', 'y4_labeller',
           'splitter', 'get_dblock', 'cfg', 'usm1_err', 'usm2_err', 'usm3_err', 'usm4_err', 'combo_err', 'usm1_err_raw',
           'usm2_err_raw', 'usm3_err_raw', 'usm4_err_raw', 'usm1_loss', 'usm2_loss', 'usm3_loss', 'usm4_loss',
           'combo_loss', 'usm_err_raw', 'combo_err_raw']

# %% 04_baseline.ipynb 2
from fastai.vision.all import *
import gc

# %% 04_baseline.ipynb 6
images_df=pd.read_csv('data/images_df_final.csv', dtype={'image_id':str,'clip_name':str,'labels':str})

# %% 04_baseline.ipynb 7
def y1_labeller(i): return re.sub(r"[\[\]]",'',i).split(',')[0].strip()
def y2_labeller(i): return re.sub(r"[\[\]]",'',i).split(',')[1].strip()
def y3_labeller(i): return re.sub(r"[\[\]]",'',i).split(',')[2].strip()
def y4_labeller(i): return re.sub(r"[\[\]]",'',i).split(',')[3].strip()

images_df['y1_label'] = images_df.labels.map(y1_labeller)
images_df['y2_label'] = images_df.labels.map(y2_labeller)
images_df['y3_label'] = images_df.labels.map(y3_labeller)
images_df['y4_label'] = images_df.labels.map(y4_labeller)

# %% 04_baseline.ipynb 10
def splitter(df):
    train = df.index[~df['valid']].to_list()
    valid = df.index[df['valid']].to_list()
    return train, valid

# %% 04_baseline.ipynb 14
vocab=['cadiere_forceps',
       'prograsp_forceps',
       'bipolar_forceps',
       'force_bipolar',
       'monopolar_curved_scissors',
       'tip_up_fenestrated_grasper',
       'nan',
       'grasping_retractor',
       'needle_driver',
       'bipolar_dissector',
       'stapler',
       'vessel_sealer',
       'clip_applier',
       'permanent_cautery_hook_spatula',
       'blank',
       'suction_irrigator']

# %% 04_baseline.ipynb 15
def get_dblock(item_tfms, batch_tfms):
    
    dblock = DataBlock(
        blocks=(ImageBlock,CategoryBlock(vocab=vocab),CategoryBlock(vocab=vocab),CategoryBlock(vocab=vocab),CategoryBlock(vocab=vocab)),
        n_inp=1,
        get_x=ColReader('image_id'),
        get_y=[ColReader('y1_label'),ColReader('y2_label'),ColReader('y3_label'),ColReader('y4_label')],
        splitter=splitter,
        item_tfms=item_tfms,
        batch_tfms=batch_tfms
    )
    
    return dblock

dblock = get_dblock(item_tfms=Resize((180,320), ResizeMethod.Squish), batch_tfms=[*aug_transforms(size=(180,320), min_scale=1),Normalize.from_stats(*imagenet_stats)])
dls = dblock.dataloaders(images_df, seed=42, n_workers=32)


# %% 04_baseline.ipynb 19
def cfg (i): return dls.c[:i].sum()

# defining error rate for each robotic hand tools
def usm1_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,:cfg(1)], usm1_targs)
def usm2_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,cfg(1):cfg(2)], usm2_targs)
def usm3_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,cfg(2):cfg(3)], usm3_targs)
def usm4_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): return error_rate(preds[:,cfg(3):cfg(4)], usm4_targs)

# defining combined error rate 
def combo_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs): 
    return usm1_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)+usm2_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)+usm3_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)+usm4_err(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs)

# defining error rate for each robotic hand tools for raw preds from the learner 
def usm1_err_raw(preds,targs): return error_rate(preds[:,:cfg(1)].softmax(dim=1).argmax(dim=1), targs)
def usm2_err_raw(preds,targs): return error_rate(preds[:,cfg(1):cfg(2)].softmax(dim=1).argmax(dim=1), targs)
def usm3_err_raw(preds,targs): return error_rate(preds[:,cfg(2):cfg(3)].softmax(dim=1).argmax(dim=1), targs)
def usm4_err_raw(preds,targs): return error_rate(preds[:,cfg(3):cfg(4)].softmax(dim=1).argmax(dim=1), targs)

# defining loss function for each robotic hand tools
def usm1_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,:cfg(1)], usm1_targs,**kwargs)
def usm2_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,cfg(1):cfg(2)], usm2_targs,**kwargs)
def usm3_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,cfg(2):cfg(3)], usm3_targs,**kwargs)
def usm4_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): return CrossEntropyLossFlat(reduction='mean')(preds[:,cfg(3):cfg(4)], usm4_targs,**kwargs)

# defining combined loss
def combo_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs): 
    return usm1_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)+usm2_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)+usm3_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)+usm4_loss(preds,usm1_targs,usm2_targs,usm3_targs,usm4_targs,**kwargs)

# configuring metrics and loss for learner
metrics_cfg = [usm1_loss,usm2_loss,usm3_loss,usm4_loss,usm1_err,usm2_err,usm3_err,usm4_err, combo_err]

# error rate fns for inference and validation
def usm_err_raw(preds,targs): return error_rate(preds, targs)
def combo_err_raw(preds, targs): 
    return usm_err_raw(preds[:,:cfg(1)].softmax(dim=1),targs[0])+usm_err_raw(preds[:,cfg(1):cfg(2)].softmax(dim=1),targs[1])+usm_err_raw(preds[:,cfg(2):cfg(3)].softmax(dim=1),targs[2])+usm_err_raw(preds[:,cfg(3):cfg(4)].softmax(dim=1),targs[3])

